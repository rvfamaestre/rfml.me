<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="An immersive 3D portfolio gallery by Rafael Maestre López.">
  <title>rfml — immersive portfolio</title>
  <style>
    :root {
      color-scheme: only light;
      font-size: 16px;
      --bg: #f9f9f8;
      --fg: #050505;
      --muted: rgba(0, 0, 0, 0.55);
      --shadow: rgba(0, 0, 0, 0.08);
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at top, #ffffff 0%, #f6f6f4 55%, #f0f0ee 100%);
      color: var(--fg);
      font-family: "Times New Roman", "Computer Modern", "Garamond", serif;
      letter-spacing: 0.01em;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
    }

    #root {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .gallery-root {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
      background: transparent;
    }

    .canvas-holder {
      position: absolute;
      inset: 0;
    }

    .crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 1px solid rgba(0, 0, 0, 0.28);
      background: radial-gradient(circle, rgba(255, 255, 255, 0.75) 0%, rgba(255, 255, 255, 0.05) 65%, transparent 100%);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.4), 0 8px 24px rgba(0, 0, 0, 0.12);
      pointer-events: none;
      transform: translate(-50%, -50%) scale(0.88);
      opacity: 0;
      transition: opacity 240ms ease, transform 240ms ease;
      mix-blend-mode: multiply;
      z-index: 8;
    }

    .crosshair::after {
      content: "";
      position: absolute;
      width: 2px;
      height: 2px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.75);
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }

    .crosshair.active {
      opacity: 0.75;
      transform: translate(-50%, -50%) scale(1);
    }

    .gallery-overlay {
      pointer-events: none;
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: clamp(1.75rem, 4vw, 3rem);
      mix-blend-mode: normal;
    }

    .gallery-brand {
      font-size: clamp(1.35rem, 2vw, 2rem);
      letter-spacing: 0.2em;
      text-transform: uppercase;
      pointer-events: auto;
      align-self: flex-start;
      padding: 0.3rem 0.8rem;
      border: 1px solid rgba(0, 0, 0, 0.12);
      backdrop-filter: blur(8px);
      background: rgba(255, 255, 255, 0.55);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.05);
    }

    .gallery-instructions {
      pointer-events: auto;
      align-self: flex-end;
      max-width: clamp(16rem, 24vw, 22rem);
      padding: 1.1rem 1.6rem;
      border: 1px solid rgba(0, 0, 0, 0.12);
      background: rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(12px);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.06);
      font-size: 0.85rem;
      line-height: 1.7;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .gallery-instructions span {
      display: block;
      color: var(--muted);
    }

    .labels-layer {
      pointer-events: none;
      position: absolute;
      inset: 0;
      font-size: clamp(0.75rem, 1vw, 0.9rem);
      letter-spacing: 0.08em;
    }

    .frame-label {
      position: absolute;
      left: 0;
      top: 0;
      text-align: center;
      color: var(--fg);
      text-transform: uppercase;
      padding: 0.35rem 0.75rem 0.6rem;
      background: rgba(255, 255, 255, 0.72);
      border: 1px solid rgba(0, 0, 0, 0.08);
      border-radius: 999px;
      box-shadow: 0 18px 34px rgba(0, 0, 0, 0.09);
      backdrop-filter: blur(14px);
      opacity: 0;
      transform: translate(-50%, 0);
      transition: opacity 320ms ease, transform 320ms ease;
      white-space: nowrap;
    }

    .frame-label strong {
      display: block;
      font-weight: 500;
    }

    .frame-label span {
      display: block;
      font-size: 0.7em;
      letter-spacing: 0.12em;
      color: var(--muted);
    }

    .frame-label.visible {
      opacity: 1;
    }

    .project-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(32px);
      background: rgba(248, 248, 248, 0.92);
      pointer-events: none;
      opacity: 0;
      transition: opacity 550ms cubic-bezier(0.77, 0, 0.18, 1);
      padding: clamp(1.5rem, 4vw, 3rem);
      gap: clamp(1rem, 3vw, 2.5rem);
    }

    .project-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }

    .project-media {
      position: relative;
      width: min(72vw, 1040px);
      max-height: 68vh;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid rgba(0, 0, 0, 0.08);
      box-shadow: 0 40px 80px rgba(0, 0, 0, 0.12), 0 12px 30px rgba(0, 0, 0, 0.06);
      background: #fff;
      overflow: hidden;
    }

    .project-media img,
    .project-media video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .project-meta {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      gap: 0.4rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }

    .project-meta h2 {
      margin: 0;
      font-size: clamp(1.5rem, 3vw, 2.5rem);
      font-weight: 500;
    }

    .project-meta span {
      font-size: clamp(0.7rem, 1vw, 0.85rem);
      color: var(--muted);
    }

    .project-controls {
      position: absolute;
      inset: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      pointer-events: none;
    }

    .project-arrow {
      width: clamp(3.5rem, 6vw, 4.5rem);
      height: clamp(3.5rem, 6vw, 4.5rem);
      border-radius: 50%;
      border: 1px solid rgba(0, 0, 0, 0.12);
      background: rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(18px);
      box-shadow: 0 22px 40px rgba(0, 0, 0, 0.12);
      display: grid;
      place-items: center;
      font-size: 0.8rem;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: var(--fg);
      pointer-events: auto;
      opacity: 0;
      transition: opacity 320ms ease, transform 320ms ease;
    }

    .project-overlay.active .project-arrow {
      opacity: 0.78;
    }

    .project-arrow:hover {
      opacity: 1;
      transform: scale(1.03);
    }

    .project-arrow.left {
      margin-left: -2rem;
    }

    .project-arrow.right {
      margin-right: -2rem;
    }

    .project-close {
      position: absolute;
      top: clamp(2rem, 5vw, 3rem);
      right: clamp(2rem, 5vw, 3rem);
      border: 1px solid rgba(0, 0, 0, 0.12);
      background: rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(18px);
      padding: 0.55rem 0.9rem;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      font-size: 0.7rem;
      pointer-events: auto;
      cursor: pointer;
      transition: opacity 260ms ease, transform 260ms ease;
      opacity: 0;
    }

    .project-overlay.active .project-close {
      opacity: 0.85;
    }

    .project-close:hover {
      transform: translateY(-2px);
      opacity: 1;
    }

    .status-indicator {
      position: absolute;
      bottom: clamp(1.5rem, 4vw, 2.5rem);
      left: 50%;
      transform: translateX(-50%);
      letter-spacing: 0.18em;
      text-transform: uppercase;
      font-size: 0.75rem;
      color: rgba(0, 0, 0, 0.42);
      pointer-events: none;
    }

    @media (max-width: 900px) {
      .gallery-overlay {
        padding: 1.6rem;
      }

      .gallery-brand {
        font-size: 1.1rem;
        letter-spacing: 0.18em;
      }

      .gallery-instructions {
        letter-spacing: 0.1em;
        font-size: 0.75rem;
      }

      .project-media {
        width: 92vw;
      }

      .project-arrow {
        display: none;
      }
    }

    @media (max-width: 640px) {
      html, body {
        font-size: 15px;
      }

      .gallery-instructions {
        background: rgba(255, 255, 255, 0.88);
      }

      .frame-label {
        font-size: 0.7rem;
      }
    }
  </style>
  <script>
    if (location.hostname !== "localhost" && location.protocol === "http:") {
      location.replace(`https://${location.host}${location.pathname}${location.search}${location.hash}`);
    }
  </script>
</head>
<body>
  <div id="root"></div>
  <script type="module">
    import { useEffect, useRef, useState } from "https://cdn.jsdelivr.net/npm/react@18.2.0/+esm";
    import { createRoot } from "https://cdn.jsdelivr.net/npm/react-dom@18.2.0/client/+esm";
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import { jsx, jsxs } from "https://cdn.jsdelivr.net/npm/react@18.2.0/jsx-runtime/+esm";

    const PROJECTS = [
      {
        title: "Parametric Skyline",
        date: "2024",
        category: "3D Design",
        image: "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Circuit Ballet",
        date: "2023",
        category: "Electronics",
        image: "https://images.unsplash.com/photo-1527430253228-e93688616381?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Volatility Atlas",
        date: "2022",
        category: "Quant Finance",
        image: "https://images.unsplash.com/photo-1556740749-887f6717d7e4?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Tactile Compiler",
        date: "2024",
        category: "Software",
        image: "https://images.unsplash.com/photo-1498050108023-c5249f4df085?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Adaptive Control Field",
        date: "2023",
        category: "Control Systems",
        image: "https://images.unsplash.com/photo-1482192597420-4817fdd7e8b0?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Automaton Chorus",
        date: "2024",
        category: "Automation",
        image: "https://images.unsplash.com/photo-1520607162513-77705c0f0d4a?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Nonlinear Poem",
        date: "2022",
        category: "Mathematics",
        image: "https://images.unsplash.com/photo-1523580846011-d3a5bc25702b?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Monochrome Atelier",
        date: "2021",
        category: "Fashion",
        image: "https://images.unsplash.com/photo-1490481651871-ab68de25d43d?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Silver Halide Study",
        date: "2020",
        category: "Photography",
        image: "https://images.unsplash.com/photo-1516035069371-29a1b244cc32?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Quiet Relief",
        date: "2022",
        category: "Charity",
        image: "https://images.unsplash.com/photo-1495159659121-2e3f43d3ee1b?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Playfield 2049",
        date: "2024",
        category: "Videogames",
        image: "https://images.unsplash.com/photo-1511512578047-dfb367046420?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Flux Vignette",
        date: "2023",
        category: "Experimental",
        image: "https://images.unsplash.com/photo-1533587851505-d119e13fa0d9?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Quantum Loom",
        date: "2025",
        category: "AI Research",
        image: "https://images.unsplash.com/photo-1518770660439-4636190af475?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Luminous Archive",
        date: "2024",
        category: "Digital Heritage",
        image: "https://images.unsplash.com/photo-1524995997946-a1c2e315a42f?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Kinetic Façade",
        date: "2024",
        category: "Architecture",
        image: "https://images.unsplash.com/photo-1535920527002-b35e96722eb9?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Harmonic Plasma",
        date: "2023",
        category: "Plasma Systems",
        image: "https://images.unsplash.com/photo-1472214103451-9374bd1c798e?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Nebula Loom",
        date: "2025",
        category: "Generative Art",
        image: "https://images.unsplash.com/photo-1517694712202-14dd9538aa97?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Cerulean Circuit",
        date: "2023",
        category: "Wearables",
        image: "https://images.unsplash.com/photo-1512436991641-6745cdb1723f?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Fractal Choir",
        date: "2024",
        category: "Audio Synthesis",
        image: "https://images.unsplash.com/photo-1527529482837-4698179dc6ce?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Carbon Lattice Lab",
        date: "2023",
        category: "Material Science",
        image: "https://images.unsplash.com/photo-1489515217757-5fd1be406fef?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Euclid Drift",
        date: "2024",
        category: "Robotics",
        image: "https://images.unsplash.com/photo-1545239351-1141bd82e8a6?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Velvet Tensor",
        date: "2025",
        category: "Deep Learning",
        image: "https://images.unsplash.com/photo-1487412947147-5cebf100ffc2?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Prism Caravan",
        date: "2023",
        category: "Immersive Media",
        image: "https://images.unsplash.com/photo-1515003197210-e0cd71810b5f?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Polar Graphite",
        date: "2022",
        category: "Art Installation",
        image: "https://images.unsplash.com/photo-1500534314209-a25ddb2bd429?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Aero Tapestry",
        date: "2024",
        category: "Aerospace",
        image: "https://images.unsplash.com/photo-1514381676171-86c99fdd0d19?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Verdant Mesh",
        date: "2023",
        category: "Sustainability",
        image: "https://images.unsplash.com/photo-1529312266912-b2e0f2030bba?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Sepia Signal",
        date: "2021",
        category: "Analog Revival",
        image: "https://images.unsplash.com/photo-1517142089942-ba376ce32a0b?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Stochastic Bloom",
        date: "2024",
        category: "Bioinformatics",
        image: "https://images.unsplash.com/photo-1521737604893-d14cc237f11d?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Meridian Array",
        date: "2025",
        category: "Satellite Systems",
        image: "https://images.unsplash.com/photo-1470240731273-7821a6eeb6bd?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Chromatic Prism",
        date: "2023",
        category: "Lighting Design",
        image: "https://images.unsplash.com/photo-1500535708195-a5fc1a0fb4c4?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Basilisk Relay",
        date: "2022",
        category: "Security",
        image: "https://images.unsplash.com/photo-1485827404703-89b55fcc595e?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Reverie Loom",
        date: "2024",
        category: "Storytelling",
        image: "https://images.unsplash.com/photo-1501594907352-04cda38ebc29?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Cascade Indigo",
        date: "2023",
        category: "Water Systems",
        image: "https://images.unsplash.com/photo-1526481280695-3c4693fc3241?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Ripple Field",
        date: "2025",
        category: "IoT",
        image: "https://images.unsplash.com/photo-1517048676732-d65bc937f952?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Lunar Relay",
        date: "2024",
        category: "Space Comms",
        image: "https://images.unsplash.com/photo-1473929151137-1c7e7efc61b2?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Echo Silk",
        date: "2022",
        category: "Textiles",
        image: "https://images.unsplash.com/photo-1521572267360-ee0c2909ff34?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Glacial Vector",
        date: "2025",
        category: "Climate Analytics",
        image: "https://images.unsplash.com/photo-1502082553048-f009c37129b9?auto=format&fit=crop&w=1200&q=80"
      },
      {
        title: "Orchid Dynamo",
        date: "2023",
        category: "Energy Systems",
        image: "https://images.unsplash.com/photo-1516117172878-fd2c41f4a759?auto=format&fit=crop&w=1200&q=80"
      }
    ];

    const cubicBezier = (t, p1x, p1y, p2x, p2y) => {
      const cx = 3 * p1x;
      const bx = 3 * (p2x - p1x) - cx;
      const ax = 1 - cx - bx;
      const cy = 3 * p1y;
      const by = 3 * (p2y - p1y) - cy;
      const ay = 1 - cy - by;

      const sampleCurveX = (t) => ((ax * t + bx) * t + cx) * t;
      const sampleCurveY = (t) => ((ay * t + by) * t + cy) * t;
      const sampleDerivX = (t) => (3 * ax * t + 2 * bx) * t + cx;

      let x = t;
      for (let i = 0; i < 6; i++) {
        const dx = sampleCurveX(x) - t;
        if (Math.abs(dx) < 1e-4) break;
        const d = sampleDerivX(x);
        if (Math.abs(d) < 1e-6) break;
        x -= dx / d;
      }

      let lo = 0;
      let hi = 1;
      while (sampleCurveX(x) - t > 1e-4) {
        if (sampleCurveX(x) > t) {
          hi = x;
        } else {
          lo = x;
        }
        x = 0.5 * (lo + hi);
      }

      return sampleCurveY(x);
    };

    const easeStandard = (t) => cubicBezier(t, 0.65, 0.05, 0.36, 1);
    const easeDramatic = (t) => cubicBezier(t, 0.77, 0, 0.18, 1);

    function GalleryExperience() {
      const containerRef = useRef(null);
      const labelsLayerRef = useRef(null);
      const [activeIndex, setActiveIndex] = useState(null);
      const [viewMode, setViewMode] = useState("gallery");
      const [isSceneReady, setSceneReady] = useState(false);
      const [pointerLocked, setPointerLocked] = useState(false);

      const runtimeRef = useRef({
        scene: null,
        renderer: null,
        camera: null,
        clock: null,
        frameItems: [],
        hovered: null,
        raycaster: new THREE.Raycaster(),
        pointer: new THREE.Vector2(),
        controls: {
          yaw: 0,
          pitch: -0.1,
          targetYaw: 0,
          targetPitch: -0.1,
          dragging: false,
          lastPointer: { x: 0, y: 0 }
        },
        keyboard: {
          forward: false,
          backward: false,
          left: false,
          right: false,
          up: false,
          down: false
        },
        transition: null,
        labels: [],
        projectPlane: new THREE.Plane(new THREE.Vector3(0, 0, 1), 0),
        disposed: false,
        requestId: null,
        textureLoader: null,
        loadQueue: [],
        loadedCount: 0,
        viewState: "gallery",
        active: null,
        audio: null,
        ambienceStarted: false,
        readyNotified: false,
        homeLookTarget: null,
        orientationFlip: null,
        pointerLocked: false,
        pointerLockSuppressClick: false,
        pointerLockReleaseReason: null,
        supportsPointerLock: true
      });

      useEffect(() => {
        runtimeRef.current.viewState = viewMode;
      }, [viewMode]);

      useEffect(() => {
        runtimeRef.current.active = activeIndex;
      }, [activeIndex]);

      useEffect(() => {
        const container = containerRef.current;
        const labelsLayer = labelsLayerRef.current;
        if (!container || !labelsLayer) return;

        const runtime = runtimeRef.current;
        runtime.disposed = false;
        runtime.readyNotified = false;
        setSceneReady(false);
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf7f7f5);

        const fog = new THREE.Fog(0xf5f5f3, 18, 48);
        scene.fog = fog;

        const camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 0.1, 120);
        const initialCameraPosition = new THREE.Vector3(0, 1.85, 0);
        const initialLookTarget = new THREE.Vector3(0, 1.6, -6);
        camera.position.copy(initialCameraPosition);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.domElement.style.touchAction = "none";
        renderer.domElement.style.cursor = "crosshair";
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.78);
        scene.add(ambientLight);

        const keyLight = new THREE.SpotLight(0xffffff, 1.1, 80, Math.PI / 5, 0.45, 1);
        keyLight.position.set(-6, 12, 8);
        keyLight.target.position.set(0, 1, 0);
        scene.add(keyLight);
        scene.add(keyLight.target);

        const rimLight = new THREE.DirectionalLight(0xf8f8ff, 0.42);
        rimLight.position.set(7, 6, -4);
        scene.add(rimLight);

        const floorGeometry = new THREE.PlaneGeometry(120, 120, 1, 1);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xfdfdfc, roughness: 0.92, metalness: 0.04 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -4;
        floor.receiveShadow = false;
        scene.add(floor);

        const ceiling = floor.clone();
        ceiling.position.y = 12;
        ceiling.material = floor.material.clone();
        scene.add(ceiling);

        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xfafaf8, roughness: 0.85, metalness: 0.02 });
        const wallGeometry = new THREE.PlaneGeometry(120, 48);
        const northWall = new THREE.Mesh(wallGeometry, wallMaterial);
        northWall.position.set(0, 4, -40);
        const southWall = northWall.clone();
        southWall.position.set(0, 4, 40);
        southWall.rotation.y = Math.PI;
        const eastWall = northWall.clone();
        eastWall.position.set(40, 4, 0);
        eastWall.rotation.y = -Math.PI / 2;
        const westWall = northWall.clone();
        westWall.position.set(-40, 4, 0);
        westWall.rotation.y = Math.PI / 2;
        scene.add(northWall, southWall, eastWall, westWall);

        runtime.scene = scene;
        runtime.renderer = renderer;
        runtime.camera = camera;
        runtime.clock = new THREE.Clock();
        runtime.supportsPointerLock = typeof renderer.domElement.requestPointerLock === "function";
        const galleryCenter = new THREE.Vector3(0, 1.6, 0);

        camera.lookAt(initialLookTarget);
        const homeDirection = new THREE.Vector3().subVectors(initialLookTarget, initialCameraPosition).normalize();
        runtime.controls.yaw = Math.atan2(homeDirection.x, homeDirection.z);
        runtime.controls.targetYaw = runtime.controls.yaw;
        runtime.controls.pitch = Math.asin(THREE.MathUtils.clamp(homeDirection.y, -0.999, 0.999));
        runtime.controls.targetPitch = runtime.controls.pitch;
        runtime.homePosition = initialCameraPosition.clone();
        runtime.homeQuaternion = camera.quaternion.clone();
        runtime.homeYaw = runtime.controls.yaw;
        runtime.homePitch = runtime.controls.pitch;
        runtime.homeLookTarget = initialLookTarget.clone();
        runtime.orientationFlip = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);

        runtime.textureLoader = new THREE.TextureLoader();
        runtime.textureLoader.setCrossOrigin("anonymous");
        runtime.frameItems = [];
        runtime.labels = Array.from(labelsLayer.querySelectorAll(".frame-label"));

        const perRing = 12;
        const angleStep = (Math.PI * 2) / perRing;
        const baseRadius = 8.8;
        const ringSpacing = 2.6;
        const frameBackMaterial = new THREE.MeshPhysicalMaterial({
          color: 0xfdfdfd,
          roughness: 0.32,
          metalness: 0.12,
          clearcoat: 0.28,
          clearcoatRoughness: 0.6
        });

        const frameInsetMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

        const frameGeometry = new THREE.BoxGeometry(1.8, 1.8, 0.12);
        const mattingGeometry = new THREE.PlaneGeometry(1.66, 1.66);
        const artworkGeometry = new THREE.PlaneGeometry(1.48, 1.48);

        const createFrameGroup = (project, index) => {
          const group = new THREE.Group();
          const frameMesh = new THREE.Mesh(frameGeometry, frameBackMaterial.clone());
          frameMesh.castShadow = false;
          group.add(frameMesh);

          const mattingMesh = new THREE.Mesh(mattingGeometry, frameInsetMaterial.clone());
          mattingMesh.position.z = 0.065;
          group.add(mattingMesh);

          const artworkMaterial = new THREE.MeshBasicMaterial({ color: index % 2 === 0 ? 0x101010 : 0x0e0e0e });
          const artworkMesh = new THREE.Mesh(artworkGeometry, artworkMaterial);
          artworkMesh.position.z = 0.072;
          artworkMesh.userData.isArtwork = true;
          group.add(artworkMesh);

          const ringIndex = Math.floor(index / perRing);
          const ringPosition = index % perRing;
          const baseTheta = ringPosition * angleStep + ringIndex * 0.32 + (index % 3) * 0.05;
          const radius = baseRadius + ringSpacing * ringIndex + Math.sin(ringPosition * 0.92) * 0.4;
          const heightBase = (ringPosition % 6 - 2.5) * 0.9 + ringIndex * 0.7;
          const phase = Math.random() * Math.PI * 2;
          const speed = 0.042 + ringIndex * 0.004;
          const bobAmplitude = 0.38 + Math.random() * 0.28;
          const bobFrequency = 0.55 + Math.random() * 0.3;
          const radialPulse = 0.05 + Math.random() * 0.035;

          const initialRadius = radius + Math.sin(phase) * radialPulse;
          const initialHeight = heightBase + Math.sin(phase) * bobAmplitude;
          group.position.set(
            Math.cos(baseTheta) * initialRadius,
            initialHeight,
            Math.sin(baseTheta) * initialRadius
          );

          const initialFocus = new THREE.Vector3(0, galleryCenter.y, 0);
          group.lookAt(initialFocus);
          group.rotateY(Math.PI);

          const highlight = new THREE.Mesh(
            new THREE.PlaneGeometry(1.86, 1.86),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 })
          );
          highlight.position.z = 0.06;
          group.add(highlight);

          scene.add(group);

          return {
            index,
            project,
            group,
            frameMesh,
            artworkMesh,
            highlight,
            orbit: {
              baseTheta,
              radius,
              heightBase,
              speed,
              bobAmplitude,
              bobFrequency,
              radialPulse,
              phase,
              timeOffset: 0,
              isFrozen: false,
              frozenTime: 0
            },
            loaded: false,
            loading: false,
            texture: null
          };
        };

        PROJECTS.forEach((project, index) => {
          const item = createFrameGroup(project, index);
          runtime.frameItems.push(item);
        });

        const loadCanvasTexture = (item) => {
          if (item.loaded || item.loading) return;
          item.loading = true;
          runtime.textureLoader.load(
            item.project.image,
            (texture) => {
              texture.colorSpace = THREE.SRGBColorSpace;
              texture.anisotropy = Math.min(16, renderer.capabilities.getMaxAnisotropy());
              const material = new THREE.MeshBasicMaterial({ map: texture });
              material.blending = THREE.NormalBlending;
              material.transparent = false;
              item.artworkMesh.material = material;
              item.texture = texture;
              item.loaded = true;
              item.loading = false;
              runtime.loadedCount += 1;
              if (!runtimeRef.current.readyNotified && runtime.loadedCount >= Math.min(PROJECTS.length, 3)) {
                runtimeRef.current.readyNotified = true;
                setSceneReady(true);
              }
            },
            undefined,
            () => {
              item.loading = false;
            }
          );
        };

        runtime.loadQueue = runtime.frameItems.slice(0, Math.min(8, runtime.frameItems.length));
        runtime.loadQueue.forEach(loadCanvasTexture);

        const ensureAdjacentLoaded = (index) => {
          if (typeof index !== "number") return;
          const indices = [index, index - 1, index + 1].map((i) => (i + PROJECTS.length) % PROJECTS.length);
          indices.forEach((idx) => {
            const frame = runtime.frameItems[idx];
            loadCanvasTexture(frame);
          });
        };

        runtime.loadCanvasTexture = loadCanvasTexture;
        runtime.ensureAdjacentLoaded = ensureAdjacentLoaded;

        const startAmbience = () => {
          if (runtime.ambienceStarted) return;
          runtime.ambienceStarted = true;
          const audio = new Audio("https://cdn.pixabay.com/audio/2022/02/17/audio_b96afeeb39.mp3");
          audio.crossOrigin = "anonymous";
          audio.loop = true;
          audio.volume = 0.28;
          audio.play().catch(() => {});
          runtime.audio = audio;
        };

        const exitFullscreen = () => {
          const exit = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
          if (document.fullscreenElement && exit) {
            try {
              const result = exit.call(document);
              if (result && typeof result.catch === "function") {
                result.catch(() => {});
              }
            } catch (err) {
              /* noop */
            }
          }
        };

        const requestImmersiveMode = () => {
          runtime.pointerLockReleaseReason = null;
          if (runtime.supportsPointerLock && renderer.domElement.requestPointerLock) {
            if (document.pointerLockElement !== renderer.domElement) {
              renderer.domElement.requestPointerLock();
              runtime.pointerLockSuppressClick = true;
            }
          } else {
            runtime.pointerLocked = false;
            runtime.pointerLockSuppressClick = false;
          }
          if (!document.fullscreenElement && container.requestFullscreen) {
            container.requestFullscreen().catch(() => {});
          }
        };

        const onPointerDown = (event) => {
          if (event.button !== 0) return;
          event.preventDefault();
          startAmbience();
          if (runtime.viewState !== "gallery") return;
          if (runtime.supportsPointerLock) {
            if (!runtime.pointerLocked) {
              requestImmersiveMode();
            }
          } else {
            runtime.controls.dragging = true;
            runtime.controls.lastPointer.x = event.clientX;
            runtime.controls.lastPointer.y = event.clientY;
            const rect = renderer.domElement.getBoundingClientRect();
            runtime.pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            runtime.pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            renderer.domElement.style.cursor = "grabbing";
            if (renderer.domElement.setPointerCapture) {
              try {
                renderer.domElement.setPointerCapture(event.pointerId);
              } catch (err) {
                /* noop */
              }
            }
          }
        };

        const onPointerUp = (event) => {
          if (event.button !== 0) return;
          if (!runtime.supportsPointerLock) {
            runtime.controls.dragging = false;
            if (runtime.viewState === "gallery") {
              renderer.domElement.style.cursor = "crosshair";
            }
            if (renderer.domElement.releasePointerCapture) {
              try {
                renderer.domElement.releasePointerCapture(event.pointerId);
              } catch (err) {
                /* noop */
              }
            }
          }
          if (runtime.pointerLocked) return;
          const rect = renderer.domElement.getBoundingClientRect();
          runtime.pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          runtime.pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        };

        const onPointerMove = (event) => {
          if (runtime.pointerLocked && runtime.viewState === "gallery") {
            const sensitivity = 0.0018;
            runtime.controls.targetYaw -= event.movementX * sensitivity;
            runtime.controls.targetPitch = THREE.MathUtils.clamp(
              runtime.controls.targetPitch - event.movementY * sensitivity,
              -0.75,
              0.6
            );
            runtime.pointer.set(0, 0);
          } else {
            const rect = renderer.domElement.getBoundingClientRect();
            runtime.pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            runtime.pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            if (!runtime.supportsPointerLock && runtime.controls.dragging && runtime.viewState === "gallery") {
              const dx = event.clientX - runtime.controls.lastPointer.x;
              const dy = event.clientY - runtime.controls.lastPointer.y;
              runtime.controls.targetYaw -= dx * 0.0022;
              runtime.controls.targetPitch = THREE.MathUtils.clamp(
                runtime.controls.targetPitch - dy * 0.0016,
                -0.65,
                0.45
              );
              runtime.controls.lastPointer.x = event.clientX;
              runtime.controls.lastPointer.y = event.clientY;
            }
          }
        };

        const onClick = (event) => {
          if (runtime.pointerLockSuppressClick) {
            runtime.pointerLockSuppressClick = false;
            return;
          }
          if (runtime.viewState !== "gallery") return;
          if (runtime.hovered) {
            event.preventDefault();
            openFrame(runtime.hovered);
          }
        };

        const onWheel = (event) => {
          event.preventDefault();
          if (runtime.viewState === "gallery") {
            const direction = new THREE.Vector3();
            runtime.camera.getWorldDirection(direction);
            const zoomIntensity = THREE.MathUtils.clamp(event.deltaY * 0.0012, -1.8, 1.8);
            runtime.camera.position.addScaledVector(direction, zoomIntensity);
            runtime.camera.position.y = THREE.MathUtils.clamp(runtime.camera.position.y, 0.8, 9);
          } else if (runtime.viewState === "project" && Math.abs(event.deltaY) > 18) {
            if (event.deltaY > 0) {
              navigateProject(1);
            } else {
              navigateProject(-1);
            }
          }
        };

        const keyMap = {
          KeyW: "forward",
          KeyS: "backward",
          KeyA: "left",
          KeyD: "right",
          KeyQ: "down",
          KeyE: "up",
          Space: "up",
          ShiftLeft: "down",
          ShiftRight: "down"
        };

        const onKeyDown = (event) => {
          if (event.code === "Escape" && runtime.viewState === "project") {
            closeProject();
            return;
          }
          if (runtime.viewState === "project") {
            if (event.code === "ArrowRight") {
              navigateProject(1);
            } else if (event.code === "ArrowLeft") {
              navigateProject(-1);
            }
          }
          const key = keyMap[event.code];
          if (key) {
            runtime.keyboard[key] = true;
            if (["forward", "backward", "left", "right"].includes(key)) {
              event.preventDefault();
            }
          }
        };

        const onKeyUp = (event) => {
          const key = keyMap[event.code];
          if (key) {
            runtime.keyboard[key] = false;
          }
        };

        const onResize = () => {
          const { clientWidth, clientHeight } = container;
          renderer.setSize(clientWidth, clientHeight);
          camera.aspect = clientWidth / clientHeight;
          camera.updateProjectionMatrix();
        };

        renderer.domElement.addEventListener("pointerdown", onPointerDown);
        renderer.domElement.addEventListener("pointerup", onPointerUp);
        renderer.domElement.addEventListener("pointercancel", onPointerUp);
        renderer.domElement.addEventListener("pointermove", onPointerMove);
        renderer.domElement.addEventListener("click", onClick);
        renderer.domElement.addEventListener("wheel", onWheel, { passive: false });
        window.addEventListener("keydown", onKeyDown);
        window.addEventListener("keyup", onKeyUp);
        window.addEventListener("resize", onResize);
        const onPointerLockChange = () => {
          const locked = document.pointerLockElement === renderer.domElement;
          runtime.pointerLocked = locked;
          const releaseReason = runtime.pointerLockReleaseReason;
          runtime.pointerLockReleaseReason = null;
          setPointerLocked(locked);
          if (locked) {
            runtime.pointer.set(0, 0);
            renderer.domElement.style.cursor = "none";
          } else {
            runtime.pointerLockSuppressClick = false;
            renderer.domElement.style.cursor = releaseReason === "project"
              ? "default"
              : (runtime.viewState === "gallery" ? "crosshair" : "default");
            runtime.pointer.set(0, 0);
            if (releaseReason !== "project") {
              exitFullscreen();
            }
          }
        };
        const onPointerLockError = () => {
          runtime.pointerLocked = false;
          runtime.pointerLockReleaseReason = null;
          runtime.pointerLockSuppressClick = false;
          setPointerLocked(false);
          renderer.domElement.style.cursor = runtime.viewState === "gallery" ? "crosshair" : "default";
          exitFullscreen();
        };
        document.addEventListener("pointerlockchange", onPointerLockChange);
        document.addEventListener("pointerlockerror", onPointerLockError);

        const openFrame = (frameItem) => {
          if (runtime.transition) return;
          if (document.pointerLockElement === renderer.domElement) {
            runtime.pointerLockReleaseReason = "project";
            document.exitPointerLock();
          }
          runtime.controls.dragging = false;
          ensureAdjacentLoaded(frameItem.index);
          const focusPoint = frameItem.group.getWorldPosition(new THREE.Vector3());
          const frameForward = new THREE.Vector3(0, 0, 1).applyQuaternion(frameItem.group.quaternion).normalize();
          const toPosition = focusPoint.clone().addScaledVector(frameForward, 2.6).add(new THREE.Vector3(0, 0.25, 0));
          const toQuaternion = new THREE.Quaternion().setFromRotationMatrix(
            new THREE.Matrix4().lookAt(toPosition, focusPoint, new THREE.Vector3(0, 1, 0))
          );
          runtime.transition = {
            type: "enter",
            start: performance.now(),
            duration: 2200,
            fromPosition: camera.position.clone(),
            toPosition,
            fromQuaternion: camera.quaternion.clone(),
            toQuaternion,
            focusFrame: frameItem
          };
          const planar = new THREE.Vector2(toPosition.x - focusPoint.x, toPosition.z - focusPoint.z);
          runtime.controls.targetYaw = Math.atan2(planar.x, planar.y);
          runtime.controls.targetPitch = Math.atan2(
            toPosition.y - focusPoint.y,
            Math.max(planar.length(), 1e-4)
          );
          runtime.viewState = "transitioning";
          setViewMode("transitioning");
          setActiveIndex(frameItem.index);
        };

        const closeProject = () => {
          if (runtime.transition || runtime.viewState !== "project") return;
          runtime.transition = {
            type: "exit",
            start: performance.now(),
            duration: 1650,
            fromPosition: camera.position.clone(),
            toPosition: runtime.homePosition.clone(),
            fromQuaternion: camera.quaternion.clone(),
            toQuaternion: runtime.homeQuaternion.clone(),
            focusFrame: runtime.frameItems[runtime.active ?? activeIndex ?? 0]
          };
          runtime.controls.targetYaw = runtime.homeYaw;
          runtime.controls.targetPitch = runtime.homePitch;
          runtime.viewState = "transitioning";
          setViewMode("transitioning");
        };

        const navigateProject = (direction) => {
          if (typeof runtime.active !== "number" || runtime.viewState !== "project") return;
          const nextIndex = (runtime.active + direction + PROJECTS.length) % PROJECTS.length;
          setActiveIndex(nextIndex);
          ensureAdjacentLoaded(nextIndex);
        };

        runtime.internalClose = closeProject;
        runtime.internalNavigate = navigateProject;

        const animate = () => {
          if (runtime.disposed) return;
          runtime.requestId = requestAnimationFrame(animate);
          const delta = Math.min(runtime.clock.getDelta(), 0.045);
          const elapsedTime = runtime.clock.elapsedTime;

          runtime.controls.yaw = THREE.MathUtils.damp(runtime.controls.yaw, runtime.controls.targetYaw, 4, delta);
          runtime.controls.pitch = THREE.MathUtils.damp(runtime.controls.pitch, runtime.controls.targetPitch, 4, delta);

          const moveVector = new THREE.Vector3(
            (runtime.keyboard.right ? 1 : 0) - (runtime.keyboard.left ? 1 : 0),
            (runtime.keyboard.up ? 1 : 0) - (runtime.keyboard.down ? 1 : 0),
            (runtime.keyboard.backward ? 1 : 0) - (runtime.keyboard.forward ? 1 : 0)
          );

          if (runtime.viewState === "gallery") {
            const directionVector = new THREE.Vector3(
              Math.sin(runtime.controls.yaw),
              Math.tan(runtime.controls.pitch),
              Math.cos(runtime.controls.yaw)
            ).normalize();
            const sideways = new THREE.Vector3().crossVectors(directionVector, new THREE.Vector3(0, 1, 0)).normalize();
            const up = new THREE.Vector3(0, 1, 0);

            const moveSpeed = 4.6;
            if (moveVector.lengthSq() > 0) {
              camera.position.addScaledVector(directionVector, -moveVector.z * moveSpeed * delta);
              camera.position.addScaledVector(sideways, moveVector.x * moveSpeed * delta);
              camera.position.addScaledVector(up, moveVector.y * moveSpeed * delta);
            }

            camera.position.y = THREE.MathUtils.clamp(camera.position.y, -1, 8);

            const lookTarget = new THREE.Vector3(
              camera.position.x + Math.sin(runtime.controls.yaw) * Math.cos(runtime.controls.pitch),
              camera.position.y + Math.sin(runtime.controls.pitch),
              camera.position.z + Math.cos(runtime.controls.yaw) * Math.cos(runtime.controls.pitch)
            );
            camera.lookAt(lookTarget);
          }

          runtime.hovered = null;
          if (runtime.pointerLocked) {
            runtime.pointer.set(0, 0);
          }
          runtime.raycaster.setFromCamera(runtime.pointer, camera);
          const intersects = runtime.raycaster.intersectObjects(
            runtime.frameItems.map((item) => item.artworkMesh),
            false
          );
          if (intersects.length > 0) {
            const match = runtime.frameItems.find((item) => item.artworkMesh === intersects[0].object);
            runtime.hovered = match || null;
          }

          runtime.frameItems.forEach((item, index) => {
            const frame = item.group;
            const orbit = item.orbit;
            const isActiveIndex = typeof runtime.active === "number" && runtime.active === index;
            const isTransitionFocus = runtime.transition?.focusFrame === item;
            const isFrozen = runtime.viewState !== "gallery" && (isActiveIndex || isTransitionFocus);

            if (orbit) {
              if (isFrozen) {
                if (!orbit.isFrozen) {
                  orbit.isFrozen = true;
                  orbit.frozenTime = elapsedTime;
                }
              } else {
                if (orbit.isFrozen) {
                  orbit.timeOffset += elapsedTime - orbit.frozenTime;
                  orbit.isFrozen = false;
                }
                const orbitTime = elapsedTime - orbit.timeOffset;
                const orbitAngle = orbit.baseTheta + orbitTime * orbit.speed;
                const radial = orbit.radius + Math.sin(orbitTime * 0.45 + orbit.phase) * orbit.radialPulse;
                const x = Math.cos(orbitAngle) * radial;
                const z = Math.sin(orbitAngle) * radial;
                const y = orbit.heightBase + Math.sin(orbitTime * orbit.bobFrequency + orbit.phase) * orbit.bobAmplitude;
                frame.position.set(x, y, z);

                const lookTarget = new THREE.Vector3(0, galleryCenter.y + Math.sin(orbitTime * 0.18 + orbit.phase) * 0.25, 0);
                const baseQuat = new THREE.Quaternion().setFromRotationMatrix(
                  new THREE.Matrix4().lookAt(frame.position.clone(), lookTarget, new THREE.Vector3(0, 1, 0))
                );
                const facingQuat = baseQuat.multiply(runtime.orientationFlip);
                const driftQuat = new THREE.Quaternion().setFromEuler(
                  new THREE.Euler(
                    Math.sin(orbitTime * 0.6 + orbit.phase) * 0.04,
                    Math.cos(orbitTime * 0.5 + orbit.phase) * 0.06,
                    Math.sin(orbitTime * 0.4 + orbit.phase) * 0.02
                  )
                );
                const finalQuat = facingQuat.clone().multiply(driftQuat);
                frame.quaternion.slerp(finalQuat, 0.08);
              }
            }

            const highlightTarget = runtime.hovered === item ? 0.32 : 0;
            item.highlight.material.opacity = THREE.MathUtils.damp(
              item.highlight.material.opacity,
              highlightTarget,
              4,
              delta
            );

            if (!item.loaded) {
              const distance = frame.position.distanceTo(camera.position);
              if (distance < 18) {
                loadCanvasTexture(item);
              }
            }
          });

          if (runtime.transition) {
            const now = performance.now();
            const t = THREE.MathUtils.clamp((now - runtime.transition.start) / runtime.transition.duration, 0, 1);
            const eased = runtime.transition.type === "enter" ? easeDramatic(t) : easeStandard(t);

            camera.position.lerpVectors(runtime.transition.fromPosition, runtime.transition.toPosition, eased);
            camera.quaternion.slerp(runtime.transition.toQuaternion, eased);

            if (t >= 1) {
              if (runtime.transition.type === "enter") {
                runtime.viewState = "project";
                setViewMode("project");
                runtime.active = runtime.transition.focusFrame.index;
              } else {
                runtime.viewState = "gallery";
                setViewMode("gallery");
                runtime.active = null;
                setActiveIndex(null);
                runtime.controls.yaw = runtime.homeYaw;
                runtime.controls.pitch = runtime.homePitch;
                runtime.controls.targetYaw = runtime.homeYaw;
                runtime.controls.targetPitch = runtime.homePitch;
              }
              runtime.transition = null;
            }
          }

          const updateLabels = () => {
            const { clientWidth, clientHeight } = renderer.domElement;
            runtime.frameItems.forEach((item, idx) => {
              const el = runtime.labels[idx];
              if (!el) return;
              if (runtime.viewState !== "gallery" && runtime.active === idx) {
                el.classList.remove("visible");
                return;
              }
              const worldPosition = item.group.getWorldPosition(new THREE.Vector3());
              const projected = worldPosition.clone().project(camera);
              const isVisible = projected.z < 1 && projected.z > -1;
              if (!isVisible) {
                el.classList.remove("visible");
                return;
              }
              const x = (projected.x * 0.5 + 0.5) * clientWidth;
              const y = (-projected.y * 0.5 + 0.5) * clientHeight;
              const distance = camera.position.distanceTo(worldPosition);
              const offset = THREE.MathUtils.clamp(420 / Math.max(distance, 0.0001), 18, 72);
              el.style.left = `${x}px`;
              el.style.top = `${y}px`;
              el.style.transform = `translate(-50%, ${offset}px)`;
              if (runtime.viewState === "gallery") {
                el.classList.add("visible");
              } else {
                el.classList.remove("visible");
              }
            });
          };

          updateLabels();
          renderer.render(scene, camera);
        };

        animate();

        return () => {
          runtime.disposed = true;
          cancelAnimationFrame(runtime.requestId);
          renderer.domElement.removeEventListener("pointerdown", onPointerDown);
          renderer.domElement.removeEventListener("pointerup", onPointerUp);
          renderer.domElement.removeEventListener("pointercancel", onPointerUp);
          renderer.domElement.removeEventListener("pointermove", onPointerMove);
          renderer.domElement.removeEventListener("click", onClick);
          renderer.domElement.removeEventListener("wheel", onWheel);
          window.removeEventListener("keydown", onKeyDown);
          window.removeEventListener("keyup", onKeyUp);
          window.removeEventListener("resize", onResize);
          document.removeEventListener("pointerlockchange", onPointerLockChange);
          document.removeEventListener("pointerlockerror", onPointerLockError);

          runtime.frameItems.forEach((item) => {
            if (item.texture) {
              item.texture.dispose();
            }
            item.group.traverse((child) => {
              if (child.isMesh) {
                child.geometry.dispose();
                if (child.material?.dispose) {
                  child.material.dispose();
                }
              }
            });
            scene.remove(item.group);
          });
          renderer.dispose();
          container.removeChild(renderer.domElement);
          runtime.audio?.pause();
          runtime.audio = null;
        };
      }, []);

      useEffect(() => {
        const runtime = runtimeRef.current;
        if (typeof activeIndex === "number") {
          runtime.active = activeIndex;
          runtime.frameItems[activeIndex] && runtime.frameItems[activeIndex].highlight && (runtime.frameItems[activeIndex].highlight.material.opacity = 0);
          runtime.internalActivateIndex = activeIndex;
        }
      }, [activeIndex]);

      useEffect(() => {
        if (viewMode === "project" && typeof activeIndex === "number") {
          runtimeRef.current.ensureAdjacentLoaded?.(activeIndex);
        }
      }, [viewMode, activeIndex]);

      useEffect(() => {
        const dom = runtimeRef.current.renderer?.domElement;
        if (!dom) return;
        if (pointerLocked) {
          dom.style.cursor = "none";
        } else {
          dom.style.cursor = viewMode === "gallery" ? "crosshair" : "default";
        }
      }, [viewMode, pointerLocked]);

      const closeProject = () => {
        runtimeRef.current.internalClose?.();
      };

      const navigateProject = (direction) => {
        runtimeRef.current.internalNavigate?.(direction);
      };

      return jsxs("div", {
        className: "gallery-root",
        children: [
          jsx("div", { className: "canvas-holder", ref: containerRef }),
          jsx("div", { className: pointerLocked ? "crosshair active" : "crosshair", "aria-hidden": "true" }),
          jsxs("div", {
            className: "gallery-overlay",
            children: [
              jsx("div", { className: "gallery-brand", children: "rfml" }),
              jsxs("div", {
                className: "labels-layer",
                ref: labelsLayerRef,
                children: PROJECTS.map((project) =>
                  jsxs("div", {
                    className: "frame-label",
                    children: [
                      jsx("strong", { children: project.title }),
                      jsx("span", { children: project.date })
                    ]
                  }, `label-${project.title}`)
                )
              }),
              jsxs("div", {
                className: "gallery-instructions",
                children: [
                  jsx("span", { children: "Click to enter immersive mode" }),
                  jsx("span", { children: "Center a frame · click to dive in" }),
                  jsx("span", { children: "Move mouse to look · WASD / Space / Q / E to drift" }),
                  jsx("span", { children: "Scroll to glide" }),
                  jsx("span", { children: "Press ESC to release" })
                ]
              })
            ]
          }),
          jsxs("div", {
            className: "project-overlay" + (viewMode === "project" ? " active" : ""),
            children: typeof activeIndex === "number"
              ? [
                  jsx("button", {
                    className: "project-close",
                    onClick: closeProject,
                    children: "Return"
                  }, "close"),
                  jsxs("div", {
                    className: "project-media",
                    children: [
                      jsxs("div", {
                        className: "project-controls",
                        children: [
                          jsx("button", {
                            className: "project-arrow left",
                            onClick: () => navigateProject(-1),
                            children: "Prev"
                          }, "prev"),
                          jsx("button", {
                            className: "project-arrow right",
                            onClick: () => navigateProject(1),
                            children: "Next"
                          }, "next")
                        ]
                      }),
                      jsx("img", {
                        src: PROJECTS[activeIndex].image,
                        alt: PROJECTS[activeIndex].title,
                        loading: "lazy"
                      })
                    ]
                  }, "media"),
                  jsxs("div", {
                    className: "project-meta",
                    children: [
                      jsx("h2", { children: PROJECTS[activeIndex].title }),
                      jsx("span", {
                        children: PROJECTS[activeIndex].date +
                          (PROJECTS[activeIndex].category ? ` — ${PROJECTS[activeIndex].category}` : "")
                      })
                    ]
                  }, "meta")
                ]
              : null
          }),
          jsx("div", {
            className: "status-indicator",
            children: viewMode === "project" ? "Project View" : (pointerLocked ? "Immersive Navigation" : "Gallery Navigation")
          }),
          !isSceneReady
            ? jsx("div", {
                className: "status-indicator",
                style: { bottom: "auto", top: "50%", transform: "translate(-50%, -50%)" },
                children: "Calibrating gallery…"
              }, "loading-indicator")
            : null
        ]
      });
    }

    const root = createRoot(document.getElementById("root"));
    root.render(jsx(GalleryExperience, {}));
  </script>
</body>
</html>
